---
layout: post
title: "前端測試"
date: 2018-10-10 19:15:53 +0800
tags:
  - JavaScript
  - Thought
categories:
---


## 寫測試的理由

一開始寫測試，每個人都有的困惑肯定是「為什麼要寫測試？」，原本完成一項需求只要一個小時，但是加上寫測試可能變兩小時，工作量變兩倍，工時變長，人力成本也跟著增加，聽起來寫測試是一件完全不合理的事。

如果軟體跟罐頭一樣，經由生產線完工直接上架販售，不用維護也不用加新功能，在這個情況下，寫測試的確是不合理。

但是軟體會隨時間演進，你可能會需要修改其他人的程式碼，可能會重構三個月前自己寫下的程式碼，引入 Bug 是難以避免，沒有人能夠明白一個軟體產品的每一個角落，那些毀澀難懂的業務分支與邊際案例，一定會有當下沒有考慮到的情境，而寫了一段程式，造成其他人（或是三個月前的你）寫的程式碼直接斷成三截。

<!--more-->

### 防範未然

在開發時順手寫測試，如果你的測試「正確」且「完整」的描述了當前程式的行為，等於是多了一個小幫手，在未來的每分每秒檢查是否有人無意間破壞了你寫的功能。提醒兇手，「你寫的程式碼會讓我寫的功能壞掉，他媽還不趕快修正！！」，同時也能防範上線後才發現該 Bug。

### 測試即文件 

對於工程師，暸解一段函式、函式庫如何使用，最直觀的方式就是看「程式碼範例」，一份測試會描述程式在「每個情境下應該有的行為」，剛好可以作為完整的程式碼範例，

尤其是在 JavaScript 這樣可以寫出 Meta Programming 的語言裡，如果你不在測試裡描述 meta programming 的行為，往往難以理解該程式碼，因為 meta programming 所產生的類別與方法，都無法從程式碼中看見。

--- 

如果以上的說法太過高大上，而你又恰巧是個利己主義，這裡還有兩個理由可以參考：

### 清晰地思緒

如果你跟隨著 TDD 的實踐，先寫測試再寫程式，寫測試時能夠先思考程式的「介面」，以及各個「邊際案例」，這能夠幫助釐清思緒。

如果直接實作，常常會因為實作難易，而忽略整體介面的一致性，以及忽略邊際案例的處理。

### 自動化驗證

如果不寫測試，驗證功能的時候就必須要手動操作，一直 console.log 不累嗎？讓測試幫你吧！

## 測試的種類

### End to End 測試

### 整合測試 Integration Test

### 單元測試 Unit Test


## 合格的單元測試

Robert C. Martin，《無瑕的程式碼》一書提出單元測試應遵守 F.I.R.S.T 原則，我們可以依據該原則判斷單元測試是否合格。

### Fast

> 測試就是要快

因為測試必須在每一次的改動都被執行，如果執行全部的測試需要耗時數分鐘，會影響開發的流暢度，也肯定很難落實在每次的程式碼更動執行測試。

所以怎麼樣的算是慢的單元測試？ 大部分的測試都應該在 **50ms** 以下，如果超過，可能是因為沒有正確 mock 網路、IO 及時間相關的函式。

### Independent

> 每一個測試案例都可以被獨立執行，且互不依賴

如果 A 測試一定要在 B 測試之後跑才會成功，先跑 B 再跑 A 就會失敗，表示違反了「獨立」原則。

有三個原因讓我們必須遵守此原則:

1. 如果測試程式碼相互依賴，那些依賴的部分我們也必須要視為待測函式的輸入，而那些輸入，在程式實際運行的環境是不存在的，會讓測試缺乏真實性。 
2. 當測試失敗時，無法很快的定位錯誤，因為測試之間相互關聯，測試 A 的失敗可能是 B 造成的。 
3. 測試程式無法平行執行。

通常會違反此原則有幾個可能：
- 使用了全域變數。
- 測試案例之間共享變數，而沒有在每個測試案例前重置該變數。
- 沒有在每次測試案例執行之後將 mock 重置。

### Repeatable

> 在任何時間、地點、網路狀況，測試結果都應該相同

如果測試時好時壞，基本上就是沒用的測試，因為它無法證明程式沒有出錯。

要讓測試反覆執行都能夠呈現相同的結果，我們要盡量消除外部變因，諸如：

1. 不同的瀏覽器
2. 執行測試時，不同機器使用不同的環境變數
3. 程式中使用了時間相關功能，像是當前日期或是隨機函式
4. 通過資料庫取得資料，而資料庫會被其他環境改變
5. 通過網路取得資料

1, 2 點我們可以通過一致的測試環境設定解決，而 3, 4, 5 我們需要透過 Mock 來消除那些變因

### Self-validating

> 測試執行後應能直接判斷「失敗」或「成功」其中一種情況

基本上我們不需要擔心此一原則，因為正確使用測試框架上是不會出現該情況的。

有可能出現該情況是，在測試中完全不使用 assertion，直接使用 console.log 顯示一些資料來判段測試是否成功。

應該沒有人會這麼做吧...

### Thorough



## 單元測試的種類


## 高效的測試





